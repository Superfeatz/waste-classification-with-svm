# -*- coding: utf-8 -*-
"""svm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yh_CJp9_-f9d9EmX_38yyQ2XVWcX70ZZ

# Support Vector Machine
"""

!pip install -q kaggle

from google.colab import userdata
import os

os.environ['KAGGLE_KEY'] = "6bb9bede2c17aad6726603db6482869b"
os.environ['KAGGLE_USERNAME'] = "hafidzharridil"

!kaggle datasets download -d techsash/waste-classification-data
!unzip waste-classification-data.zip

"""Image pre-procces\
resizing and remove corrupted data
"""

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
import os

test_directory = '/content/DATASET/TEST'
train_directory = '/content/DATASET/TRAIN'

# Function to resize images in a given directory
def resize_images(directory, output_size):
    for subdir, _, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(subdir, file)
            try:
                img = Image.open(file_path)
                img = img.resize(output_size, Image.ANTIALIAS)
                img.save(file_path)
                print(f"Resized {file_path}")
            except Exception as e:
                print(f"Error processing {file_path}: {e}")

# Define the output size
output_size = (128*4, 128*4)  # Change to desired size

# Resize images in train and test directories
resize_images(train_directory, output_size)
resize_images(test_directory, output_size)

import os
from PIL import Image

# Function to remove images that cannot be identified
def remove_unidentifiable_images(directory):
    for subdir, _, files in os.walk(directory):
        for file in files:
            file_path = os.path.join(subdir, file)
            try:
                img = Image.open(file_path)
                img.verify()  # Verify that it is, in fact, an image
            except (IOError, SyntaxError) as e:
                print(f"Removing {file_path} due to error: {e}")
                os.remove(file_path)


# Remove unidentifiable images in train and test directories
remove_unidentifiable_images(train_directory)
remove_unidentifiable_images(test_directory)

"""validation data after resizing"""

import os
import random
from PIL import Image
import matplotlib.pyplot as plt

# Function to show a random image from a directory and plot its size
def show_random_image_with_size(directory):
    # List all files in the directory and subdirectories
    image_files = []
    for subdir, _, files in os.walk(directory):
        for file in files:
            if file.lower().endswith(('.jpg')):
                image_files.append(os.path.join(subdir, file))

    # Choose a random image file
    random_image_path = random.choice(image_files)

    # Open the image
    img = Image.open(random_image_path)

    # Get image size
    width, height = img.size

    # Plot the image
    plt.figure(figsize=(10, 6))

    plt.subplot(1, 2, 1)
    plt.imshow(img)
    plt.axis('off')  # Hide axes
    plt.title(f"Random Image: {os.path.basename(random_image_path)}")

    # Plot the size as a bar chart
    plt.subplot(1, 2, 2)
    plt.bar(['Width', 'Height'], [width, height], color=['blue', 'green'])
    plt.xlabel('Dimension')
    plt.ylabel('Size (pixels)')
    plt.title('Image Dimensions')

    plt.show()

# Show a random image with its size from the train directory
show_random_image_with_size(train_directory)

# Show a random image with its size from the test directory
show_random_image_with_size(test_directory)

pip install torch

"""img2vec installation"""

pip install img2vec-pytorch

"""Ekstraksi dengan img2vec\
Pemisahan data train dan test\
Penyimpanan ekstraksi ke dalam kamus data
"""

from  PIL import Image
import os
from img2vec_pytorch import Img2Vec

# prepare

img2vec = Img2Vec() # Create an instance of the Img2Vec class
data_dir = '/content/DATASET/'
train_data = os.path.join(data_dir, 'TRAIN')
test_data = os.path.join(data_dir, 'TEST')

data = {}

for j, dir_ in enumerate([train_data, test_data]):
  features = []
  labels  = []
  for category in os.listdir(dir_):
    for img_path in os.listdir(os.path.join(dir_, category)):
      img_path = os.path.join(dir_, category, img_path)
      try:
        img = Image.open(img_path).convert('RGB') # Convert image to RGB
        img_features = img2vec.get_vec(img) # Use the instance to call the method
        features.append(img_features)
        labels.append(category)
      except Exception as e:
        print(f"Error processing {img_path}: {e}") # Print the error message to help diagnose the issue

  data[['training_data', 'test_data'][j]] = features
  data[['training_labels', 'test_labels'][j]] = labels

"""Train model svm dengan beberapa kernel\
Prediksi dan evaluasi model



"""

from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

# Data training dan labels diasumsikan sudah ada dalam data['training_data'] dan data['training_labels']

# Linear Kernel
model_linear = SVC(kernel='linear', C=1.0, gamma='scale')
model_linear.fit(data['training_data'], data['training_labels'])

# Polynomial Kernel
model_poly = SVC(kernel='poly', C=1.0, gamma='scale', degree=3)
model_poly.fit(data['training_data'], data['training_labels'])

# RBF Kernel (Default)
model_rbf = SVC(kernel='rbf', C=1.0, gamma='scale')
model_rbf.fit(data['training_data'], data['training_labels'])

# Sigmoid Kernel
model_sigmoid = SVC(kernel='sigmoid', C=1.0, gamma='scale')
model_sigmoid.fit(data['training_data'], data['training_labels'])

# Evaluate models
test_labels = np.array(data['test_labels'])  # Convert to numpy array
y_pred_linear = model_linear.predict(data['test_data'])
y_pred_poly = model_poly.predict(data['test_data'])
y_pred_rbf = model_rbf.predict(data['test_data'])
y_pred_sigmoid = model_sigmoid.predict(data['test_data'])

# Calculate accuracy
accuracy_linear = accuracy_score(test_labels, y_pred_linear)
accuracy_poly = accuracy_score(test_labels, y_pred_poly)
accuracy_rbf = accuracy_score(test_labels, y_pred_rbf)
accuracy_sigmoid = accuracy_score(test_labels, y_pred_sigmoid)

print(f"Accuracy (Linear Kernel): {accuracy_linear}")
print(f"Accuracy (Polynomial Kernel): {accuracy_poly}")
print(f"Accuracy (RBF Kernel): {accuracy_rbf}")
print(f"Accuracy (Sigmoid Kernel): {accuracy_sigmoid}")

"""Report classification"""

from sklearn.metrics import classification_report

# Predict the labels for the test data
y_pred_linear = model_linear.predict(data['test_data'])

# Print classification report for Linear Kernel
print("Classification Report for Linear Kernel:")
print(classification_report(test_labels, y_pred_linear, target_names=['O', 'R']))

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

# Assuming you have data['test_labels'] and model_linear

# Predict the labels for the test data
y_pred_linear = model_linear.predict(data['test_data'])

# Compute the confusion matrix
cm_linear = confusion_matrix(test_labels, y_pred_linear)

# Define the custom labels for the confusion matrix
custom_labels = ['YY', 'YN', 'NY', 'NN']

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm_linear, annot=True, fmt='d', cmap='Blues', xticklabels=['O', 'R'], yticklabels=['O', 'R'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for Linear Kernel')
plt.show()

# Print the confusion matrix with custom labels
print(f"{custom_labels[0]}: {cm_linear[0, 0]}")
print(f"{custom_labels[1]}: {cm_linear[0, 1]}")
print(f"{custom_labels[2]}: {cm_linear[1, 0]}")
print(f"{custom_labels[3]}: {cm_linear[1, 1]}")

from sklearn.metrics import classification_report

# Predict the labels for the test data
y_pred_poly = model_poly.predict(data['test_data'])

# Print classification report for Polynomial Kernel
print("Classification Report for Polynomial Kernel:")
print(classification_report(test_labels, y_pred_poly, target_names=['O', 'R']))

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

# Assuming you have data['test_labels'] and model_poly

# Predict the labels for the test data
y_pred_poly = model_poly.predict(data['test_data'])

# Compute the confusion matrix
cm_poly = confusion_matrix(test_labels, y_pred_poly)

# Define the custom labels for the confusion matrix
custom_labels = ['YY', 'YN', 'NY', 'NN']

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm_poly, annot=True, fmt='d', cmap='Blues', xticklabels=['O', 'R'], yticklabels=['O', 'R'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for Polynomial Kernel')
plt.show()

# Print the confusion matrix with custom labels
print(f"{custom_labels[0]}: {cm_poly[0, 0]}")
print(f"{custom_labels[1]}: {cm_poly[0, 1]}")
print(f"{custom_labels[2]}: {cm_poly[1, 0]}")
print(f"{custom_labels[3]}: {cm_poly[1, 1]}")

from sklearn.metrics import classification_report

# Predict the labels for the test data
y_pred_rbf = model_rbf.predict(data['test_data'])

# Print classification report for RBF Kernel
print("Classification Report for RBF Kernel:")
print(classification_report(test_labels, y_pred_rbf, target_names=['O', 'R']))

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.metrics import confusion_matrix

# Assuming you have data['test_labels'] and model_rbf

# Predict the labels for the test data
y_pred_rbf = model_rbf.predict(data['test_data'])

# Compute the confusion matrix
cm_rbf = confusion_matrix(test_labels, y_pred_rbf)

# Define the custom labels for the confusion matrix
custom_labels = ['YY', 'YN', 'NY', 'NN']

# Plot the confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(cm_rbf, annot=True, fmt='d', cmap='Blues', xticklabels=['O', 'R'], yticklabels=['O', 'R'])
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix for RBF Kernel')
plt.show()

# Print the confusion matrix with custom labels
print(f"{custom_labels[0]}: {cm_rbf[0, 0]}")
print(f"{custom_labels[1]}: {cm_rbf[0, 1]}")
print(f"{custom_labels[2]}: {cm_rbf[1, 0]}")
print(f"{custom_labels[3]}: {cm_rbf[1, 1]}")

"""Save model\
Tes model terhadap input image
"""

import pickle
# Save RBF Kernel model
with open('/rbfmodel.p', 'wb') as f:
    pickle.dump(model_rbf, f)
    f.close()

with open('/linearmodel.p', 'wb') as f:
    pickle.dump(model_linear, f)
    f.close()

with open('/polymodel.p',
          'wb') as f:
    pickle.dump(model_poly, f)
    f.close()

from PIL import Image
import os
from img2vec_pytorch import Img2Vec
import pickle
import numpy as np
import matplotlib.pyplot as plt # Import matplotlib for displaying images

# Load the saved model
with open('/rbfmodel.p', 'rb') as f:
    model_rbf = pickle.load(f)

# Initialize Img2Vec
img2vec = Img2Vec()

# Path to the image
image_path = '/content/DATASET/TEST/R/R_11012.jpg'

# Load the image
img = Image.open(image_path)

# Get the image features
features = img2vec.get_vec(img)

# Reshape features to a 2D array with a single sample
features = features.reshape(1, -1)

# Predict using the model
pred = model_rbf.predict(features)

# Print the prediction
print(f'Predicted Label: {pred[0]}')

# Display the image
plt.imshow(img)
plt.title(f'Predicted Label: {pred[0]}')
plt.axis('off') # Hide the axes
plt.show()

from PIL import Image
import os
from img2vec_pytorch import Img2Vec
import pickle
import numpy as np
import matplotlib.pyplot as plt # Import matplotlib for displaying images

# Load the saved model
with open('/linearmodel.p', 'rb') as f:
    model_rbf = pickle.load(f)

# Initialize Img2Vec
img2vec = Img2Vec()

# Path to the image
image_path = '/content/DATASET/TEST/R/R_11012.jpg'

# Load the image
img = Image.open(image_path)

# Get the image features
features = img2vec.get_vec(img)

# Reshape features to a 2D array with a single sample
features = features.reshape(1, -1)

# Predict using the model
pred = model_rbf.predict(features)

# Print the prediction
print(f'Predicted Label: {pred[0]}')

# Display the image
plt.imshow(img)
plt.title(f'Predicted Label: {pred[0]}')
plt.axis('off') # Hide the axes
plt.show()

from PIL import Image
import os
from img2vec_pytorch import Img2Vec
import pickle
import numpy as np
import matplotlib.pyplot as plt # Import matplotlib for displaying images

# Load the saved model
with open('/polymodel.p', 'rb') as f:
    model_rbf = pickle.load(f)

# Initialize Img2Vec
img2vec = Img2Vec()

# Path to the image
image_path = '/content/DATASET/TEST/R/R_11012.jpg'

# Load the image
img = Image.open(image_path)

# Get the image features
features = img2vec.get_vec(img)

# Reshape features to a 2D array with a single sample
features = features.reshape(1, -1)

# Predict using the model
pred = model_rbf.predict(features)

# Print the prediction
print(f'Predicted Label: {pred[0]}')

# Display the image
plt.imshow(img)
plt.title(f'Predicted Label: {pred[0]}')
plt.axis('off') # Hide the axes
plt.show()